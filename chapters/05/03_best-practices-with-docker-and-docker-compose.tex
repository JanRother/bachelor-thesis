\section{Best Practices mit Docker und Docker Compose}
\label{sec:05-03_best-practices-with-docker-and-docker-compose}

Die \nameref{ch:05_toolchain-as-code} Strategie basiert grundlegend auf der Verwendung von Containertechnologie, insbesondere von \textit{Docker} und \textit{Docker Compose}. Daher liegt an dieser Stelle auch ein großer Hebel für die Optimierung, weshalb in diesem Abschnitt Best Practices beim Umgang mit \textit{Docker} und \textit{Docker Compose} vorgestellt werden. Diese Best Practices liefern Empfehlungen, die zu Verbesserungen in den Bereichen \nameref{subsec:05-03-01_performance}, \nameref{subsec:05-03-02_security} und \nameref{subsec:05-03-03_maintainability} führen.

Dieser \autoref{sec:05-03_best-practices-with-docker-and-docker-compose} wird die \acrlong{rq} \textbf{RQ-2} (siehe \autoref{sec:01-03_objectives-and-research-questions}) beantworten.

\subsection{Performanz}
\label{subsec:05-03-01_performance}

Eine Untersuchung von \citeauthor{002:Optimizing-Cloud-Applications-with-DevOps} hat den \nameref{subsec:05-01-01_docker-container} einer Applikation im Rahmen eines zweistufigen Optimierungsprozesses verbessert und dabei sechs für die Performanz von Containern kritische Faktoren bestimmt: Prozessorauslastung (in $\%$), Speicherverbrauch (in $MB$), Antwortzeit (in $ms$), Netzwerkdurchsatz (in $Mbps$), Fehlerraten und Datenbankantwortzeit (in $ms$). Deployt wurden dabei jeweils drei Container pro Evolutionsstufe. Im Mittel konnte in allen Bereichen eine erhelbliche Verbesserung erzielt werden, darunter ein Drittel weniger Prozessorauslastung und Speichernutzung, einen um 20 \% größeren Netzwerkdurchsatz sowie eine Halbierung der Antwortzeit. Der zweistufige Optimierungsprozess umfasste dabei Maßnahmen wie die Erhöhung von Ressourceneffizient des Quellcodes, die Eliminierung von Speicherlecks oder die Verbesserung der Fehlerbehandlung \cite{002:Optimizing-Cloud-Applications-with-DevOps}. Zwar wurden die Optimierungen von \citeauthor{002:Optimizing-Cloud-Applications-with-DevOps} zu einem großen Teil an der Applikation selbst durchgeführt, dennoch verdeutlichen sie das Potential einer performanzorientierten Optimierung von Software Containern.

\textit{Docker} selbst stellt eine Übersicht über Best Practices beim Bauen von Containern bereit. Dazu gehört unter anderem das Konzept der \textbf{Multi-Stage Builds}. Es sorgt für die Trennung zwischen Erstellung und Ergebnis des \Gls{image} \Glspl{build}. Jede dieser Phasen läuft in einer anderen sogenannten Stage ab, welche jeweils nur die Daten enthalten, die für ihre Phase benötigt werden. Das resultierende Container \Gls{image} enthält somit am Ende nur die nötigen Dateien, weshalb seine Größe deutlich reduziert ist \cite{300:Building-Best-Practices}.

\textbf{Docker Ignore} kann nicht im \Gls{build} oder im \Gls{image} benötigte Dateien vom Kopieren in den Container ausschließen, indem sie in einer \texttt{.dockerignore} Datei angegeben werden. Ähnlich wie auch bei der \texttt{.gitignore} Datei in \textit{\Gls{git}}, können Wildcards verwendet werden, um zu exkludierende Dateien anzugeben. Auch dieser Schritt reduziert die Größe des finalen \Glspl{image} \cite{300:Building-Best-Practices}.

Die \textbf{Vermeidung unnötiger Paketinstallationen} reduziert die Komplexität, Dateigröße und die benötigte Zeit für \Glspl{build} und wirkt sich dadurch ebenfalls positiv auf die Performanz von Containern aus \cite{300:Building-Best-Practices}.

Ebenfalls einen Einfluss auf die Größe und die Komplexität von \Glspl{image} hat die \textbf{Nutzung von Mounting anstelle von \texttt{ADD} oder \texttt{COPY} Instruktionen} im Dockerfile. \texttt{ADD} und \texttt{COPY} erstellen bei jedem Aufruf ein neues Layer im \Gls{image}. Dateien, die auf diese Weise in das \Gls{image} kopiert werden, verbleiben dort auch dann, wenn sie in einem späteren Layer wieder gelöscht werden. Beim Mounting hingegen wird die Datei nur temporär für die Ausführung eines Befehls eingebunden und nach diesem automatisch wieder entfernt \cite{300:Building-Best-Practices}.

\subsection{Sicherheit}
\label{subsec:05-03-02_security}

Die \citetitle{300:Building-Best-Practices} beinhalten auch einige Hinweise zur Sicherheit von Containern. Den größten Einfluss hat hier die \textbf{Wahl des richtigen Base Images}, beispielsweise von \textit{DockerHub}. Dieses sollte möglichst kompakt sein und bestenfalls von einer verifizierten Quelle stammen. Drei Arten solcher verifizierten Quellen weist \textit{DockerHub} explizit aus: \q{Docker Official Images} sind die sichersten und verlässlichsten \Glspl{image}, \q{Verified Publishers} stammen von Partnerorganisationen, deren Repositories regelmäßig von \textit{Docker} geprüft werden und \q{Docker-sponsered Open Source} \Glspl{image} werden im Rahmen von durch \textit{Docker} gesponserten Open Source Projekten veröffentlicht. Für Container auf Basis von \textit{Linux} empfiehlt \textit{Docker} die \textit{Alpine} \Glspl{image} \cite{300:Building-Best-Practices}.

Regelmäßige \textbf{Updates und Rebuilds von Images} sind notwendig, da \Glspl{image} naturgemäß unveränderlich sind, wodurch es schnell zu einer Veraltung der darin enthaltenen Komponenten kommen kann. Um stets die neuesten Versionen von Abhängigkeiten im \Gls{image} zu haben, muss dieses neu gebaut werden. Mit der Option \texttt{no-cache} beim \Gls{build} kann ein vollständiger Rebuild erzwungen werden, der alle Komponenten neu von ihren Quellen bezieht \cite{300:Building-Best-Practices}.

Das bereits in \nameref{subsec:05-03-01_performance} erwähnte Konzept \textbf{Docker Ignore} wirkt sich auch positiv auf die Sicherheit von Containern aus, da es verhindert, dass ungewollt Dateien in das \Gls{image} kopiert werden, die Secrets oder andere sensible Informationen enthalten \cite{300:Building-Best-Practices}.

\nameref{sec:02-03_containerization} bietet sicherheitskritische Punkte und Angriffsflächen an vier Hauptpunkten: der Hostmaschine, der Container Engine, den Containern selbst und den Applikationen innerhalb der Container \cite{021:Docker-Security-Threat-Model-and-Best-Practices}. Eine sinnvolle Maßnahme zur Erhöhung der Sicherheit ist es, möglichst nur \textbf{Basisrechte in Containern} zu vergeben. Dies kann dadurch erreicht werden, indem ein anderer Nutzer als \texttt{root} verwendet wird, sofern die Services im Container keine Privilegien benötigen \cite{021:Docker-Security-Threat-Model-and-Best-Practices,024:Investiugating-Impact-of-Containerization-on-Deployment-Process-in-DevOps,300:Building-Best-Practices}. Container sollten bestenfalls nie \texttt{root} Rechte benötigen \cite{022:Automated-Cloud-Infrastructure-Continous-Integration-and-Continous-Delivery-using-Docker}. Der \textit{Docker Deamon} selbst benötigt zwar Privilegien auf dem \Gls{hostsystem}, alle anderen Dienste sollten jedoch nicht auf dem Host selbst laufen. Stattdessen ist \nameref{sec:02-03_containerization} selbst bereits ein guter Schutzmechanismus, da Dienste in isolierten Containern über \textit{Docker} laufen \cite{022:Automated-Cloud-Infrastructure-Continous-Integration-and-Continous-Delivery-using-Docker}.

Auch außerhalb der Container kann die Sicherheit von \nameref{sec:02-03_containerization} verbessert werden. So sollten \Gls{hostsystem} und \textit{Docker} regelmäßig aktualisiert werden, um Sicherheitslücken zu schließen. \textit{Docker} ist so konfigurierbar, dass es nur eine begrenzte Menge an Ressourcen nutzen kann, um zu verhindern, dass es das gesamte \Gls{hostsystem} auslastet. \Glspl{image} und ihre Quellen sollten stets geprüft werden, eine \Gls{container-registry} entsprechend sorgfältig ausgewählt werden. Empfohlen wird die Verwendung der \textit{Docker Container Registry} \cite{021:Docker-Security-Threat-Model-and-Best-Practices}.

Als weiteren Schutzmechanismus kann es helfen, bereits während der Entwicklung regelmäßig Sicherheitsmaßnahmen durchzuführen. Dazu gehören eine sichere Entwicklung des Quellcodes, das Scannen nach Vulnerabilitäten oder auch das Durchführen von Penetrationstests \cite{023:Setting-up-CI-CD-Pipeline-in-the-Cloud-for-Web-Application}. Die Sicherheit der Infrastruktur kann über ein Rollen- und Rechtemanagement, Verschlüsselung oder durch Monitoring erreicht werden \cite{023:Setting-up-CI-CD-Pipeline-in-the-Cloud-for-Web-Application,024:Investiugating-Impact-of-Containerization-on-Deployment-Process-in-DevOps}.

Im industriellen Kontext können größere Softwaresysteme bei der Herstellung von Sicherheit mit \textit{Docker} unterstützen. Ein Paper von \citeauthor{022:Automated-Cloud-Infrastructure-Continous-Integration-and-Continous-Delivery-using-Docker} empfiehlt dazu Tools wie \textit{Docker Bench for Security}, \textit{CoreOSs Clair}, \textit{Docker Security Scanning} oder \textit{AppArmor/SELinux} \cite{022:Automated-Cloud-Infrastructure-Continous-Integration-and-Continous-Delivery-using-Docker}.

\subsection{Wartbarkeit}
\label{subsec:05-03-03_maintainability}

Die von \textit{Docker} in den \citetitle{300:Building-Best-Practices} aufgeführten Punkte lassen sich teilweise auch dem Aspekt der Wartbarkeit zuordnen. So erhöht die \textbf{Nutzung mehrzeiliger \texttt{RUN} Befehle} die Lesbarkeit des Dockerfiles, indem sofort erkennbar wird, welche Befehle zusammengehören und in welcher Reihenfolge sie ausgeführt werden. Bei solchen mehrzeiligen Befehlen kann es auch sinnvolle sein, die eine \textbf{Sortierung der Argumente alphanumerisch aufsteigend} zu verwenden. Insbesondere bei Paketinstallationen vereinfacht ein solches Vorgehen das Hinzufügen oder Entfernen von Einträgen und verhindert doppelte Elemente \cite{300:Building-Best-Practices}.

Die \textbf{Angabe eines Arbeitsverzeichnisses} mittels \texttt{WORKDIR}, bestenfalls mit absoluten Pfaden, sorgt für Klarheit darüber, in welchem Verzeichnis die Befehle des Dockerfiles ausgeführt werden. Dies kann das Erkennen und Beheben von Fehlern erleichtern \cite{300:Building-Best-Practices}.

Das \textbf{Verwenden von Labels} ist eine weitere Möglichkeit, die Wartbarkeit von Containern zu erhöhen. Labels beschreiben den Container, indem sie beispielsweise Angaben zum verwendeten \textit{Git} Branch oder den genauen Hash des Commits enthalten. Dadurch wird es einfacher, den Container zu identifizieren und zu verstehen, welche Version in ihm enthalten ist \cite{013:Role-of-Containers-in-Reproducibility,300:Building-Best-Practices}.

\subsection{Weiteres}
\label{subsec:05-03-04_further}

Ein weiterer Best Practice bei der Verwendung von \textit{Docker} ist die \textbf{Nutzung von Standard Ports bei \texttt{EXPOSE}}. Diese Konvention fordert, dass Container standardmäßig die Ports freigeben, die auch der Dienst nutzt, welcher durch den Container bereitgestellt wird. Dies führt zu einem intuitiven Zugriff auf die Dienste und zu weniger Konflikten mit anderen Containern \cite{300:Building-Best-Practices}.

Reproduzierbarkeit ist ein weiterer wichtiger Aspekt von Docker \Glspl{image}. \textit{Docker} empfiehlt hier das \textbf{Pinnen von Versionen des Base Images}. Tags wie \texttt{latest} führen dazu, dass das \Gls{image} mit den neuesten Versionen des Base \Glspl{image} gebaut wird. Gibt es dort größere Änderungen, können Fehler auftreten. Die Angabe spezifischer Versionen reduziert das Risiko, noch sicherer ist die Angabe eines spezifischen Digsets zur Nutzung des exakt gleichen \Glspl{image} \cite{300:Building-Best-Practices}. \citeauthor{013:Role-of-Containers-in-Reproducibility} untersuchte spezifisch die Reproduzierbarkeit von Containern und hebt ebenfalls die Bedeutung gut definierter Base \Glspl{image} hervor. Reproduzierbarkeit kann positiv beeinflusst werden, indem Pakete mit fixen Versionen über Paketmanager installiert werden, Klone von Repositories mit einem spezifischen Tag oder Hash angegeben werden und Versionen von extern bezogenen Dateien exakt angegeben werden. Mounts für Volumen außerhalb des Containers sollten vermieden werden, da externe Einflüsse die Geschlossenheit des Containers stören können \cite{013:Role-of-Containers-in-Reproducibility}.

Fixe Versionen wirken sich zwar positiv auf die Reproduzierbarkeit aus, können jedoch die Aktualität von Abhängigkeiten einschränken, sofern keine regelmäßige manuelle Wartung erfolgt. Deshalb handelt es sich bei Reproduzierbarkeit, \nameref{subsec:05-03-01_performance} und \nameref{subsec:05-03-03_maintainability} gewissermaßen auch um Komplementärziele. Perfekte Reproduzierbarkeit zu erreichen kann in der Praxis durchaus auch unpraktisch sein und ungewünschte Nebeneffekte haben \cite{013:Role-of-Containers-in-Reproducibility}.

Werden konkrete Designentscheidungen für oder gegen ein spezifisches Vorgehen getroffen, müssen die in diesem Abschnitt vorgestellten Best Practices gegeneinander abgewogen und gegebenenfalls priorisiert werden. Abhängig von der konkreten Situation und dem jeweiligen Projekt- und Technologiekontext kann ein Ziel dabei wichtiger sein als ein anderes, oder umgekehrt.
