\section{Container als Basistechnologie}
\label{sec:05-01_containers-as-base-technology}

\subsection{Docker Container}
\label{subsec:05-01-01_docker-container}

Eine wichtige Anforderung im Bereich der \nameref{subsec:04-02-04_consistency-of-toolchains} ist die Reproduzierbarkeit von Umgebungen. Sie kann von vielen verschiedenen Faktoren und Komponenten eines Systems beeinflusst werden, unter ihnen Hardware und Firmware, Betriebssystem, Softwarebibliotheken, Compiler und Tools, Laufzeitumgebungen und Umgebungsvariablen. Container bieten ein Rahmenwerk, um diese Freiheitsgrade zu fixieren, indem exakte Zustände einer Softwareumgebung festgehalten werden können. Die gesamte Umgebung kann bei Bedarf verlässlich rekreiert werden, unabhängig von der zugrundeliegenden Infrastruktur \cite{013:Role-of-Containers-in-Reproducibility}. Damit leisten Container einen wichtigen Beitrag zu Reproduzierbarkeit und Konsistenz \cite{013:Role-of-Containers-in-Reproducibility,014:Managing-Container-based-Software-Development-Environments,023:Setting-up-CI-CD-Pipeline-in-the-Cloud-for-Web-Application,024:Investiugating-Impact-of-Containerization-on-Deployment-Process-in-DevOps}.

\nameref{sec:02-03_containerization} wurde bereits in \autoref{sec:02-03_containerization} motiviert. Die vorherrschende Technologie in diesem Bereich ist \textit{Docker} \cite{015:Containers-in-Software-Development,021:Docker-Security-Threat-Model-and-Best-Practices}. \textit{Docker} ist eine freie und quelloffene Software, die in der Lage ist, deutlich mehr virtuelle Umgebungen auf der gleichen Hardware zu deployen als konkurrierende Technologien. Sie kann zusammen mit Drittanbietertechnologien genutzt werden und ist kompatibel mit vielen \hyperref[sec:03-01_devops]{DevOps} Tools. \textit{Docker} ermöglicht das Bauen, Verteilen und Operieren von Anwendungen \cite{021:Docker-Security-Threat-Model-and-Best-Practices}. Das \Gls{deployment} von Containern ist dabei über mehrere Umgebungen und Clouds hinweg möglich \cite{023:Setting-up-CI-CD-Pipeline-in-the-Cloud-for-Web-Application,024:Investiugating-Impact-of-Containerization-on-Deployment-Process-in-DevOps}.

Bei Container-basierter Virtualisierung von Betriebssystemen wird eine Repräsentation des zugrundeliegenden Betriebssystems erzeugt, welche in einer isolierten Umgebung ausgeführt werden kann. Umgebungen eines Containers sind in sich geschlossen und reflektieren das in ihren Quelldaten beschriebene System ganz spezifisch. Kernprinzipien von \nameref{sec:02-03_containerization} sind die Isolierung und Virtualisierung von Prozessen, dementsprechend wird häufig von einer Virtualisierungsmethode auf Prozess- beziehungsweise auf Applikationsebene gesprochen. Damit dies möglich ist, enthalten Container alle zur Ausführung der paketierten Software notwendigen Bibliotheken und Abhängigkeiten. Üblicherweise soll ein Docker Container genau eine Applikation respektive eine einzelne Aufgabe beinhalten \cite{014:Managing-Container-based-Software-Development-Environments}.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.95\textwidth]{g-16_architecture-of-docker.png}
    \caption{Architektur von Docker \acrshort{iAa} \citeauthor{021:Docker-Security-Threat-Model-and-Best-Practices}}
    \label{fig:g-16_architecture-of-docker}
\end{figure}

Die Architektur von \textit{Docker} ist leicht vereinfacht in \autoref{fig:g-16_architecture-of-docker} dargestellt. Grundlegender Bestandteil von \textit{Docker} ist die \textbf{Docker Engine}. Sie wurde von der \textit{Docker Inc.} entwickelt und beinhaltet den \textbf{Docker Daemon}, der für die Ausführung und Verwaltung von Containern verantwortlich ist. Entwickler können den Docker Daemon über eine \textbf{Client API} ansprechen, welche wiederum mit einer \textbf{\Gls{rest} API} kommuniziert. Hierüber ist die Interaktion mit Containern sowie mit \textit{Docker} Funktionalitäten wie \texttt{docker build} zum Erstellen, \texttt{docker pull} zum Beziehen beziehungsweise Herunterladen oder \texttt{docker run} zum Ausführen von Containern möglich. \textbf{Docker \Glspl{image}} sind fast immer die Basis von Containern. Sie bestehen aus mehreren aufeinander aufbauenden Schichten, \textbf{Layer} genannt. Die unterste dieser Layer ist das \textbf{Base \Gls{image}} Jede Modifikation an einem Container führt zu einem neuen Layer im resultierenden \Gls{image}. Um Dateien über die verschiedenen Layer hinweg handhaben zu können, verwendet \textit{Docker} das \textbf{Union File System}. \Glspl{image}, die nicht lokal verfügbar sind, müssen über ein \textbf{\Gls{image} Repository} wie \textit{Docker Hub} bezogen werden. Dieses ermöglicht die private oder öffentliche Ablage von \Glspl{image}, Nutzer können dort also ihre eigene Version eines Containers veröffentlichen \cite{021:Docker-Security-Threat-Model-and-Best-Practices}.

Der Ausgangspunkt eines Docker \Glspl{image} ist immer ein \textbf{Dockerfile}. Es enthält eine deklarative Beschreibung des Base \Glspl{image} inklusive Tags und einer konkreten Version sowie Angaben zur weiteren Konfiguration der Umgebung, die im späteren Container existieren soll. Dockerfiles sind im Format einer Textdatei abgelegt. Während des durch \texttt{docker build} ausgelösten \Gls{build} Prozesses generiert \textit{Docker} aus dieser Datei ein Docker \Gls{image} \cite{020:Assessing-and-Improving-Quality-of-Docker-Artifacts}. Ein einmal erstelltes \Gls{image} ist unveränderlich (englisch \q{immutable}). Dadurch ist sichergestellt, dass bei jedem Start eines \Glspl{image} immer die exakt gleiche Umgebung zur Verfügung steht \cite{014:Managing-Container-based-Software-Development-Environments}. Ein gebautes Docker \Gls{image} kann auf \textit{DockerHub} zur Verfügung gestellt werden. Von dort aus kann es selbst als Base \Gls{image} in einem anderen Dockerfile referenziert werden.

\textit{Docker} ermöglicht neben dem Betrieb von Applikationen auch die Beschleunigung von \Gls{cicd} Prozessen. Eine Pipeline lädt zunächst das Base \Gls{image}, auf dessen Grundlage dann Anweisungen des Dockerfiles ausgeführt werden. Nach dem \Gls{build} Prozess werden die ausgeführten Zeilen für zukünftige \Glspl{build} im Cache abgelegt, wodurch Layer wiederverwendet werden können \cite{022:Automated-Cloud-Infrastructure-Continuous-Integration-and-Continuous-Delivery-using-Docker}.

Ein weiteres wichtiges Tool ist \textit{Docker Compose}, welches den Mehr-Container Betrieb mit \textit{Docker} vereinfachen soll. Das Ziel ist die Vereinfachung der Kontrolle mehrerer Containerkomponenten wie Dienste, Netzwerke oder Volumen, indem sie für beliebig viele sogenannte \textbf{Services} in einer Konfigurationsdatei im \textit{\Gls{yaml}} Format beschrieben werden. \textit{Docker Compose} bietet Kommandos zur Verwaltung ganzer Lebenszyklen einer Umgebung an und stellt eine weitere Effizienzsteigerung in Development- und Deploymentprozessen dar \cite{308:Docker-Compose-Overview}.

\subsection{Dev Container}
\label{subsec:05-01-02_dev-container}

Konsistenz und Einheitlichkeit sind auch im Entwicklungsprozess gewünschte Eigenschaften, was die Verwendung von \nameref{sec:02-03_containerization} Lösungen im \Gls{development} motiviert. Container können auf solche Weise genutzt werden, dass nur wichtige Komponenten wie Laufzeitbibliotheken oder Datenbankserver standardisiert werden (wie von \texttt{\hyperref[sec:AA-02_interview-persons]{IP-2}} gefordert, \acrshort{vgl} \autoref{subsec:AA-03-01_open-questions}), sodass die Developmentumgebung nach den persönlichen Bedürfnissen der Entwickler angepasst werden kann (wie von \texttt{\hyperref[sec:AA-02_interview-persons]{IP-1}} gefordert, \acrshort{vgl} \autoref{subsec:AA-03-01_open-questions}) \cite{014:Managing-Container-based-Software-Development-Environments}.

Die grundlegende Idee hinter einer Container-basierten Entwicklungsumgebung ist ein Software Container, welcher zusätzlich Tools, Plugins, Software und Konfiguration für \Gls{development}, Test und \Gls{deployment} enthält, ähnlich wie \autoref{fig:g-17_architecture-of-dev-containers} es zeigt. Deren Ziel ist es, eine möglichst vollständige Entkopplung der Developmentumgebung von individuellen Maschinen zu erreichen. Ein solches Konzept lässt nach \citeauthor{014:Managing-Container-based-Software-Development-Environments} erwarten, dass sein Mehrwert sich proportional zur Komplexität der Organisation verhält, in der es eingesetzt wird \cite{014:Managing-Container-based-Software-Development-Environments}. Es verspricht das klassische \qit{It works on my Machine}-Problem zu lösen \cite{204:Development-Containers-Simplified}. Eine konkrete Implementierung des beschriebenen Ansatzes sollen Development Container, oder kurz \q{Dev Container} (siehe \autoref{fig:g-17_architecture-of-dev-containers}) liefern. Dev Container ermöglichen die Nutzung von Software Containern als vollständig ausgestattete Entwicklungsumgebungen \cite{303:Introduction-to-DevContainers,305:Using-DevContainers-in-JetBrains-IDEs,306:Development-Containers}. Vereinfacht handelt es sich um Docker Container, welche zusätzlich das Projekt, die \Gls{ide} und alles weitere enthalten \cite{305:Using-DevContainers-in-JetBrains-IDEs}.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.95\textwidth]{g-17_architecture-of-dev-containers.png}
    \caption{Architektur von Dev Containern}
    \label{fig:g-17_architecture-of-dev-containers}
\end{figure}

In \autoref{fig:g-17_architecture-of-dev-containers} ist zu erkennen, wie die \nameref{fig:g-17_architecture-of-dev-containers} auf der \hyperref[fig:g-16_architecture-of-docker]{Architektur von \textit{Docker}} (siehe \autoref{fig:g-16_architecture-of-docker}) aufbaut. Ein Docker Container enthält Binärdateien, Bibliotheken und die essentiellen Prozesse der Applikation, seine Funktionsweise unterscheidet sich nicht von der gewöhnlicher \nameref{subsec:05-01-01_docker-container}. Eine neue Komponente ist das \textbf{\Gls{ide} Backend} inklusive wichtiger Einstellungen, Tools und Plugins, die für die Entwicklung an dem Projekt notwendig oder hilfreich sind. Er kann mit einer aus mehreren aktuell unterstützten \Glspl{ide} verbunden werden, welche direkt auf dem \Gls{hostsystem} laufen und lediglich ein \Gls{gui} bereitstellen, über das wie gewohnt mit dem Projekt interagiert werden kann.

Jeder Dev Container verfügt über ein eigenes \textbf{File System}, welches das Projekt mit seinen Dateien und Verzeichnissen enthält. Dieses File System kann entweder über einen \textbf{Volume Mount} direkt mit dem \Gls{hostsystem} synchronisiert werden oder der Klon eines \textit{\Gls{git}} Repositories sein. Die einzigen Installationen, die auf dem lokalen System des Entwicklers notwendig sind, um Dev Container zu nutzen, sind \textit{Docker} und eine \Gls{ide} beziehungsweise ein Editor, welcher die Verwendung von Dev Containern unterstützt.

Die \nameref{sec:02-03_containerization} von Applikationen und Entwicklungsumgebungen bietet vielfältige Möglichkeiten für Entwickler. Sie unterstützt bei der Trennung von Tools, Bibliotheken und Laufzeitumgebungen, kann Applikationen ausführen und eignet sich für den Einsatz in \acrfull{ci} und beim Testen. Genau wie Docker Container können Dev Container lokal oder in privaten und hybriden Clouds betrieben werden \cite{306:Development-Containers}. Sie können dazu beitragen, drei Prinzipien zu erfüllen, die die Produktivität im \Gls{development} steigern, indem sie die Entwicklungsumgebung vom \Gls{hostsystem} isolieren, zu ihrer Konsistenz im gesamten Entwicklungsteam beitragen und gleichzeitig ausreichend flexibel gegenüber Anpassungen an die spezifischen Bedürfnisse von Entwicklern und Projekten sind. Dies hat positive Auswirkungen auf das Onboarding neuer Entwickler, die Geschwindigkeit beim Aufsetzen des Workspace, sowie auf Cross-Plattform Kompatibilität. Außerdem können Dev Container die Zusammenarbeit fördern und Remote \Gls{development} auf entfernten Maschinen erleichtern \cite{200:Dev-Containers-Future-of-Development-Environments,202:Maximizing-Efficiency-with-Dev-Containers,305:Using-DevContainers-in-JetBrains-IDEs}.

Zusammengefasst erweitern Dev Container also die Anwendungsfälle von Containern von Operations und \Gls{deployment} auf das \Gls{development}. Unter anderem im \nameref{sec:02-01_web-development} besteht ein großer Bedarf an solchen Lösungen. \citeauthor{202:Maximizing-Efficiency-with-Dev-Containers} identifiziert zwei zentrale Anwendungsfälle in diesem Gebiet. Die Nutzung als primäre Entwicklungsumgebung und gleichzeitig in der Integration wurde bereits angerissen. Bei der Identifizierung und Behebung von Fehlern in laufenden Systemen können Dev Container ebenfalls hilfreich sein. Durch eine intuitivere Interaktion mit laufenden Containern reduzieren sie hier die weiteren Hindernisse für Entwickler. Trotz vieler Vorteile sind Dev Container nicht für jeden Anwendungsfall die passende Lösung. Ihre Abhängigkeit zu \textit{Docker}, Hardwarebeschränkungen und Beeinträchtigungen der Performanz durch eine zusätzliche Abstraktionsschicht sollten bei der Entscheidung berücksichtigt werden \cite{202:Maximizing-Efficiency-with-Dev-Containers}.

Im Folgenden soll ein Einblick in die technische Funktionsweise von Dev Containern und deren Einsatz in der Praxis gegeben werden. Das zentrale Element eines Dev Containers ist eine Konfigurationsdatei auf Projektebene, welche die deklarative Beschreibung seines Aufbaus enthält, die \texttt{devcontainer.json} \cite{202:Maximizing-Efficiency-with-Dev-Containers}. Ihr Format entspricht \textit{\Gls{json} with Comments} und sie wird standardmäßig an drei Orten im Verzeichnisbaum eines Projekts erwartet: im Wurzelverzeichnis des Projekts (\texttt{\$PROJECT\_ROOT\$/.devcontainer.json}), in einem \texttt{.devcontainer} Verzeichnis unmittelbar eine Ebene unterhalb des Wurzelverzeichnisses (\texttt{\$PROJECT\_ROOT\$/.devcontainer/devcontainer.json}) oder in maximal einem weiteren Subverzeichnis des Dateipfades (\texttt{\$PROJECT\_ROOT\$/.devcontainer/\$FOLDER\$/devcontainer.json}) \cite{204:Development-Containers-Simplified,303:Introduction-to-DevContainers,305:Using-DevContainers-in-JetBrains-IDEs}. Dadurch passt sich die Konfiguration eines Projekts beliebigen Komplexitätsebenen an, indem eine möglichst sprechende Platzierung unterstützt und die Verwendung mehrerer Konfigurationen ermöglicht wird. Zusätzliche Individualisierungen sind möglich, indem beispielsweise ein eigenes \texttt{Dockerfile} als Base \Gls{image} für den Dev Container definiert wird. Auch die Verwendung von \textit{Docker Compose} ist möglich, um mehrere Container zu orchestrieren \cite{202:Maximizing-Efficiency-with-Dev-Containers}.

Werden Dev Container zusammen mit dem Editor \textit{Visual Studio Code} von \textit{Microsoft} genutzt, werden Änderungen an der \texttt{devcontainer.json} Datei automatisch erkannt und dem Nutzer wird proaktiv ein Rebuild des Containers vorgeschlagen. Auch ist dann die Angabe von spezifischen Erweiterungen und deren Einstellungen möglich. Diese können deklarativ angegeben werden und integrieren dann automatisch beim Erstellen des Dev Containers bestimmte Softwarekomponenten direkt im Container \cite{201:How-to-develop-with-Dev-Containers}. \textit{Microsoft} unternimmt mit dem \citetitle{306:Development-Containers} Standard außerdem einen Versuch zur Standardisierung von Dev Containern. Er beinhaltet neben der technischen Spezifikation eine \Gls{json} Referenz, eine Liste aus Tools, in denen die Verwendung von Dev Containern aktuell unterstützt wird, sowie eine Sammlung sogenannter Features, deren Zweck es ist, besonders einfach über die Konfiguration in Dev Containern installierbar zu sein. Die Spezifikation enthält einen Überblick über allgemeine Konfigurationen wie den Namen des Dev Containers, Szenario-bezogene Eigenschaften für Dockerfiles, Docker \Glspl{image} oder \textit{Docker Compose}, Tool-spezifische Einstellungen, Optionen für Skripte in bestimmten Lebenszyklusphasen des Containers, Angaben zu Mindestanforderungen an die Hardware und Einstellungen für die Portfreigabe. Außerdem finden sich dort Details zu Datentypen und deren Formatierungen sowie eine Beschreibung zur Verwendung von Variablen \cite{306:Development-Containers}.

Durch die zahlreichen Möglichkeiten ist im Grunde genommen eine beliebig komplexe und individuelle Konfiguration eines Dev Containers möglich. Der überwiegende Teil der Attribute ist jedoch optional. Eine minimale Konfiguration für eine voll funktionsfähige Umgebung muss den Namen des Dev Containers (\texttt{name}), das Base \Gls{image} (\texttt{image}) und die wichtigsten Abhängigkeiten (\texttt{features}) enthalten. Empfehlenswert ist außerdem die Verwendung von Lifecycle Scripts (\texttt{initializeCommand}, \texttt{postCreateCommand}, \texttt{postStartCommand} und \texttt{postAttachCommand}) \cite{204:Development-Containers-Simplified}.

Der Blogger \citeauthor{203:Dev-Environment-as-a-Code-with-DevContainers-Dotfiles-and-GitHub-Codespaces} beschreibt in dem Artikel \citetitle{203:Dev-Environment-as-a-Code-with-DevContainers-Dotfiles-and-GitHub-Codespaces} einen Ansatz für Entwicklungsumgebungen, der sich auf Dev Container stützt. Er zeigt dort unter anderem die typische Anatomie einer Entwicklungsumgebung, bestehend aus persönlichen und projektbezogenen Konfigurationen beziehungsweise Tools. Im Kontext der Individualisierung greift er unter anderem auf die Idee von \hyperref[sec:03-04_dotfiles]{Dotfiles} zurück, mit deren Hilfe er seine Entwicklungsumgebung personalisiert \cite{203:Dev-Environment-as-a-Code-with-DevContainers-Dotfiles-and-GitHub-Codespaces}.

\textit{GitHub Codespaces}, ein Produkt von \textit{GitHub}, ermöglicht die Nutzung von Dev Containern in der Cloud und besitzt die Fähigkeit, solche Dotfiles Repositories einzubinden. Folgt die Installationsdatei einer der in \autoref{sec:03-04_dotfiles} beschriebenen Namenskonventionen, kann sie automatisch aus einem persönlichen Dotfiles Repository geladen und zusammen mit den restlichen Konfigurationsdateien in den Dev Container kopiert werden \cite{304:Personalizing-GitHub-Codespaces-for-your-Account}. Dies ermöglicht jedem Entwickler die Angabe eines eigenen Dotfiles Repositorys mit einer individuellen Konfiguration seiner Developmentumgebung, ohne diese jedoch in den zentralen Ressourcen des Projekts ablegen zu müssen. \textit{Visual Studio Code} unterstützt die Verwendung von Dotfiles ebenfalls, sofern diese in den Nutzereinstellungen konfiguriert ist \cite{201:How-to-develop-with-Dev-Containers}. Alternativ besteht die Möglichkeit, die Einstellungen des Editors über ein \textit{GitHub} Konto mit der Cloud zu synchronisieren \cite{304:Personalizing-GitHub-Codespaces-for-your-Account}.
