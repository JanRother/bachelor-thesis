\section{GitOps}
\label{sec:03-03_gitops}

Anders als bei \hyperref[sec:03-01_devops]{DevOps} stehen in GitOps, welches ursprünglich von \textit{Weaveworks} entwickelt wurde, klare Beschreibungen des Konzepts zur Verfügung. Dafür ist das Modell jedoch noch recht jung und unerforscht. \cite{009:GitOps-Evolution-of-DevOps} GitOps stellt die Weichen für einen deklarativen und automatisierten Ansatz, der anwendbar sein soll auf die Verwaltung von Infrastruktur, die Verbesserung der Skalierbarkeit sowie die Reduzierung divergenter Konfigurationen. Zentrales und namensgebendes Element von GitOps ist das \Gls{vcs} \textit{\Gls{git}}. Es hat insofern eine große Bedeutung für das Konzept, als dass sich alle Konfigurationen der Infrastruktur und Applikation im Repository befinden. \cite{024:Investiugating-Impact-of-Containerization-on-Deployment-Process-in-DevOps}

Aktuelle Entwicklungen zeigen auch für den \hyperref[sec:03-01_devops]{DevOps} Bereich einen klaren Trend zu GitOps, welches zunehmend an Popularität gewinnt \cite{024:Investiugating-Impact-of-Containerization-on-Deployment-Process-in-DevOps}. Der \textit{Gartner Hype Cycle for Emerging Technologies} betonte im Jahr 2024 die Steigerung der Produktivität von Entwicklern als einen von vier großen technologischen Trends. GitOps ist auf der Kurve (siehe \autoref{fig:g-02_gartner-hype-cycle-2024}) weit oben gelistet. \textit{Gartner} prognostiziert, dass bereits in zwei Jahren oder weniger der so genannte \qit{Peak of inflated Expectations} erreicht sein könnte \cite{106:Gartner-2024-Hype-Cycle-for-Emerging-Technologies}, welchen eine Technologie durchlaufen muss, um das \qit{Plateau of Productivity} erreichen zu können \cite{108:Gartner-Hype-Cycle}. Mit GitOps verwandte oder durch GitOps verwendete Tools erleben eine ähnliche Entwicklung. Die Anzahl der Nutzer auf \textit{\Gls{github}} ist steigend und auch die Verwendung des \Gls{cicd} Tools \textit{\Gls{github-actions}} wächst. \cite{008:GitOps-Approach-to-Cloud-Cluster-System-Deployment}

GitOps eignet sich besonders gut für die Verwendung bei \gls{cloud-native} Applikationen. Erleichtert wird die Einführung in Entwicklungsteams dadurch, dass hauptsächlich Tools zum Einsatz kommen, mit denen die Entwickler bereits vertraut sind, als wichtigstes unter ihnen selbstverständlich \textit{\Gls{git}}. \cite{109:GitOps} \textit{\Gls{git}} wird in der Philosophie von GitOps als \q{Single Source of Truth} betrachtet. Das Repository eines Projekts beschreibt den gewünschten Zustand von Infrastruktur, Abhängigkeiten und Toolchain (nachfolgend \q{(Software-)Umgebung} genannt), sodass Änderungen jederzeit zentralisiert vorgenommen werden können. \cite{007:Analysis-of-Declarative-and-Pull-based-Deployment-Models-on-GitOps,010:Efficient-Application-Deployment-GitOps-for-Faster-and-Secure-CI-CD-Cycles,109:GitOps} Eine Herangehensweise an das \Gls{deployment} von Software ist der imperative Ansatz, bei welchem eine bestimmte Spezifikation hintereinander, beispielsweise durch Entwickler oder \Gls{cicd} Pipelines, ausgeführt wird. Der deklarative Ansatz von GitOps grenzt sich ganz bewusst von imperativem \Gls{deployment} ab. Während bei letzterem die einzelnen Schritte in Form konkreter Anweisungen angegeben werden, wird in einem deklarativen Ansatz lediglich der gewünschte Zielzustand beschrieben. Dadurch kommt dieses Vorgehen oft mit einem Zehntel der benötigten \Gls{loc} aus. \cite{007:Analysis-of-Declarative-and-Pull-based-Deployment-Models-on-GitOps}

GitOps kommt mit einer Menge qualitativer Mehrwerte. Ein wichtiger Beitrag zum \Gls{deployment} ist die Erhöhung von Geschwindigkeit und Häufigkeit, ohne dass ein Wechsel der Tools erforderlich wird \cite{008:GitOps-Approach-to-Cloud-Cluster-System-Deployment,109:GitOps}. Dies ist deshalb möglich, weil verschiedene Versionen der Konfiguration auf unterschiedliche Zielumgebungen, Kunden oder Anforderungen abgestimmt und bereitgestellt werden können, wobei sich zugleich mehrere Projekte eine Konfiguration teilen können \cite{008:GitOps-Approach-to-Cloud-Cluster-System-Deployment}. Die unkomplizierte Wiederherstellung vorheriger Stände einer Umgebung ist über Revisionen in \textit{\Gls{git}} möglich \cite{008:GitOps-Approach-to-Cloud-Cluster-System-Deployment,010:Efficient-Application-Deployment-GitOps-for-Faster-and-Secure-CI-CD-Cycles,109:GitOps}. Die Verwaltung von \textit{Credentials} ist deutlich einfacher, da beim \Gls{deployment} die Tools auf das Repository zugreifen \cite{008:GitOps-Approach-to-Cloud-Cluster-System-Deployment,109:GitOps} und der Bedarf entfällt, dass Entwickler selbst Zugang zu Deploymentumgebungen benötigen \cite{010:Efficient-Application-Deployment-GitOps-for-Faster-and-Secure-CI-CD-Cycles}. Insgesamt beeinflusst die Implementierung von GitOps die Sicherheit beim \Gls{deployment} der Software posititv \cite{008:GitOps-Approach-to-Cloud-Cluster-System-Deployment,010:Efficient-Application-Deployment-GitOps-for-Faster-and-Secure-CI-CD-Cycles,109:GitOps}. Entwickler haben einen besseren und transparenteren Überblick über ein \Gls{deployment}, dessen deklarative Konfiguration überwiegend selbst-dokumentierend ist \cite{008:GitOps-Approach-to-Cloud-Cluster-System-Deployment,109:GitOps}. Klare Commit Messages können als erweiterte Dokumentation dienen \cite{008:GitOps-Approach-to-Cloud-Cluster-System-Deployment} und jede Änderung der Konfiguration im Repository führt automatisch zu einem neuen Commit \cite{010:Efficient-Application-Deployment-GitOps-for-Faster-and-Secure-CI-CD-Cycles}, wodurch eine lückenlose und dauerhaft abrufbare Historie der Softwareumgebung entsteht \cite{008:GitOps-Approach-to-Cloud-Cluster-System-Deployment,010:Efficient-Application-Deployment-GitOps-for-Faster-and-Secure-CI-CD-Cycles,109:GitOps}. Sowohl ihre Evolution als auch ihre Beschreibung ist für das gesamte Entwicklungsteam sichtbar \cite{109:GitOps}. Oftmals sind Repositories aus Diensten wie \textit{\Gls{github}} sehr intuitiv integrierbar in andere Entwicklungswerkzeuge, beispielsweise Projektmanagementtools wie \textit{Atlassian Jira} \cite{008:GitOps-Approach-to-Cloud-Cluster-System-Deployment}. Generell führt die größere Unabhängigkeit des Designs von spezifischen Tools zu mehr Flexibilität, Austauschbarkeit und (Re-)Kombinierbarkeit von Toolchains \cite{010:Efficient-Application-Deployment-GitOps-for-Faster-and-Secure-CI-CD-Cycles}.

Auch quantitativ lassen sich Vorteile von GitOps benennen. Neben der Reduktion von \Gls{loc} in der gesamten Konfiguration eines Projekts sowie in einzelnen Dateien können Präzision und Struktur der \Gls{codebase} erhöht werden. GitOps fordert eine logischere Anordnung von Verzeichnis- und Dateistrukturen, was zu einer besseren Lesbarkeit und damit zu weniger Einarbeitungszeit auf Seite der Entwickler beiträgt. Messbar sind diese Vorteile über Metriken wie die Summe aller Dateien oder die maximale Tiefe des Verzeichnisbaums eines Projekts. \cite{008:GitOps-Approach-to-Cloud-Cluster-System-Deployment}

GitOps kann als Ergänzung des \hyperref[sec:03-01_devops]{DevOps} Ansatzes verstanden werden. Es komplettiert die einzelnen Phasen des Prozesses aus \autoref{fig:g-05_devops-workflow} durch die Abgrenzung verschiedener Bereiche und die Festlegung konkreter Verantwortlichkeiten. Dieser verbesserte Prozessablauf wird in \autoref{fig:g-06_gitops-workflow} sichtbar:

\begin{figure}[h]
    \centering
    \includegraphics[width=0.95\textwidth]{g-06_gitops-workflow.png}
    \caption{GitOps Prozessablauf (vereinfacht) \acrshort{iAa} \citeauthor{008:GitOps-Approach-to-Cloud-Cluster-System-Deployment}}
    \label{fig:g-06_gitops-workflow}
\end{figure}

Die strenge Definition von GitOps nennt zwei in den Prozess involvierte Repositories als Untergrenze. Ein \textbf{Application Repository} enthält den Quellcode der Applikation sowie die Manifeste für ihr \Gls{deployment}. In einem \textbf{Environment Configuration Repository} sind alle aktiven Manifeste abgelegt, die zum \Gls{deployment} auf die aktuelle Zielumgebung notwendig sind. Weitere Repositories können bei Bedarf, beispielsweise im Falle mehrerer Services mit getrennter \Gls{codebase}, beliebig ergänzt werden. \cite{109:GitOps}

Grundsätzlich werden bei GitOps zwei Ansätze für deklaratives \Gls{deployment} unterschieden:

\begin{itemize}
    \item \textbf{Push-based} Deployment und
    \item \textbf{Pull-based} Deployment.
\end{itemize}

Ausgangspunkt eines Durchlaufs der Pipelines sind in beiden Fällen Änderungen am Application Repository. Bis zum Ablegen der vollständig gebauten Software beziehungsweise ihrer Umgebung in Form von Container \Glspl{image} in einem Repository sind beide Ansätze identisch. Zunächst lösen Änderungen am Application Repository, beispielsweise in Form eines Pushs über das \Gls{vcs} oder eines Merge Requests die \Gls{build} Pipeline aus. Diese stellt die resultierenden Container \Glspl{image} in einer \Gls{container-registry} bereit und aktualisiert anschließend die verwandten Einträge im Environment Repository. \cite{007:Analysis-of-Declarative-and-Pull-based-Deployment-Models-on-GitOps} Der Unterschied liegt nun darin, wie Applikation und Umgebung auf Änderungen reagieren und wodurch diese Änderungen erkannt werden.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.95\textwidth]{g-07_gitops-push-based-deployment.png}
    \caption{GitOps Push-based Deployment \acrshort{iAa} \citeauthor{109:GitOps}}
    \label{fig:g-07_gitops-push-based-deployment}
\end{figure}

Beim \textbf{Push-based Deployment} (siehe \autoref{fig:g-07_gitops-push-based-deployment}) lösen diese Änderungen am Deployment Repository eine Deployment Pipeline aus. Diese stellt daraufhin die gesamte Umgebung, wie sie durch die Konfiguration vorgegeben ist, bereit. \cite{109:GitOps}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.95\textwidth]{g-08_gitops-pull-based-deployment.png}
    \caption{GitOps Pull-based Deployment \acrshort{iAa} \citeauthor{109:GitOps}}
    \label{fig:g-08_gitops-pull-based-deployment}
\end{figure}

Das \textbf{Pull-based Deployment} (siehe \autoref{fig:g-08_gitops-pull-based-deployment}) verfügt über einen zusätzlichen Operator, welcher permanent die Umgebung überwacht. Dafür prüft er einen Soll-Stand aus der Image Registry und dem Environment Repository sowie optional auch den Ist-Stand aus der aktuellen Umgebung. Sollte es Abweichungen geben, ist er eigenständig in der Lage, den Soll-Stand wiederherzustellen. Hierzu kann er auch aktuelle \Glspl{image} aus der Image Registry anwenden. \cite{109:GitOps}

Beim Push-based Deployment ist es notwendig, dass die Pipeline über Credentials zur Zielumgebung verfügt. Änderungen an der Umgebung bei diesem Ansatz werden außerdem nur dann vorgenommen, wenn sich das Application Repository ändert. Dahingegen sind Umgebungen, die auf einem Pull-based Deployment Ansatz basieren, deutlich stabiler gegenüber Änderungen in beide Richtungen. Ein großer Nachteil ist dann jedoch die Komplexität einer Pull-based Architektur, die eines zusätzlichen Operators bedarf. \cite{109:GitOps}

\hyperref[sec:03-01_devops]{DevOps} und GitOps teilen sich Konzepte wie Inkremente, Kontinuität oder Automatisierung. \hyperref[sec:03-01_devops]{DevOps} betrachtet eher die Zusammenarbeit zwischen \Gls{development} und Operations, wohingegen GitOps die Entwickler fokussiert. \cite{009:GitOps-Evolution-of-DevOps} Beide Ansätze schreiben keine konkreten Tools vor.
